# 数组和切片
[The way to go 第七章](https://www.kancloud.cn/kancloud/the-way-to-go/72485)

## 数组
### 概念
数组是具有**相同唯一类型**的一组**已编号**且**长度固定**的数据项序列（这是一种**同构**的数据结构）
- 相同唯一类型(同构)：数组中的所有元素必须是**完全相同**的数据类型
	- 同构 vs 异构对比：
		同构（数组）：[1, 2, 3, 4, 5]← 所有元素都是整数
		异构（结构体）：{name: "Alice", age: 30, active: true}← 不同类型字段
- 已编号：数组元素通过**从0开始**的**数字索引**来访问
- 长度固定：数组一旦创建，其长度就**不能改变**

### 声明格式，数组常量
var identifier [len]type
"**数组常量**"（Array Literal）指的是在代码中直接书写数组的初始值，用大括号 {}括起来
``arr3 := [5]int{10, 20, 30, 40, 50}``
```golang
var b = [4]int{1,2,3,4}
//注意 [5]int 可以从左边起开始忽略：[10]int {1, 2, 3} :这是一个有 10 个元素的数组，除了前三个元素外其他元素都为 0
var c = [5]int{1: 1,3: 2} 
//索引1(数组中第二个)是1，索引3是2，其他为零值
d := [...]int{1,2,3,4,5} 
//[...]会根据后面提供的元素个数自动设置长度
```

数组**长度**：len(arr1)
数组**容量**：cap(arr1)
数组的长度和容量相同

数组是**可变的**：
可变意味着创建后，对象的内部状态（内容）可以被修改。
不可变意味着创建后，对象的内容就不能被改变。
**字符串**是不可变的（immutable）

### 数组是值类型
```golang
var arr1 = new([5]int)  // arr1 的类型是 *[5]int（指针）
var arr2 [5]int         // arr2 的类型是 [5]int（值）
```



**赋值时内存拷贝**(值传递)：
```golang
// 情况1：值类型数组的赋值（会产生拷贝）
var arr2 [5]int = [5]int{1, 2, 3, 4, 5}
arr3 := arr2           // 这里会发生完整的内存拷贝
arr3[2] = 100         // 只修改 arr3，不影响 arr2

fmt.Println(arr2[2])  // 输出: 3（未被修改）
fmt.Println(arr3[2])  // 输出: 100
```



**函数参数传递时内存拷贝**：
```golang
func modifyArray(arr [5]int) {
    arr[2] = 999  // 修改的是副本，不影响原数组
}

func main() {
    myArray := [5]int{1, 2, 3, 4, 5}
    modifyArray(myArray)
    fmt.Println(myArray[2])  // 输出: 3（未被修改）
}
```
问题：当数组很大时，这种拷贝会消耗较多内存和时间



**使用指针避免拷贝**：
```golang
func modifyArrayByPointer(arr *[5]int) {
    arr[2] = 999  // 通过指针修改原数组
    // 或者显式解引用：(*arr)[2] = 999
}

func main() {
    myArray := [5]int{1, 2, 3, 4, 5}
    modifyArrayByPointer(&myArray)  // 传递数组的地址
    fmt.Println(myArray[2])         // 输出: 999（已被修改）
}
```
更常见的做法：使用切片（slice）

### 多维数组
虽然基本的数组是一维的，但可以通过嵌套创建多维数组
```golang
//常量语法创建多维数组
a2 := [2][3]int{
		{2, 2, 2},
		{3, 4, 5},
	}
```
```golang
// 二维数组：表示3×3的棋盘
var board [3][3]string

// 初始化棋盘
board = [3][3]string{
    {"-", "-", "-"},
    {"-", "-", "-"},
    {"-", "-", "-"},
}

// 下棋
board[1][1] = "X"  // 在中心位置放X
```
多维数组的核心特性：在同一个维度上，所有**子数组**的**长度必须相同**
Go语言的多维数组是矩形式的，但切片（slice）的数组可以模拟**锯齿状结构**
```golang
// 切片的数组：可以创建"锯齿状"多维结构
var jagged [3][]int // 长度为3的数组，每个元素是一个int切片

// 每个切片的长度可以不同！
jagged[0] = []int{1, 2, 3}       // 长度3
jagged[1] = []int{4, 5}          // 长度2  
jagged[2] = []int{6, 7, 8, 9}    // 长度4

// 这样就形成了锯齿状结构：
// □ □ □
// □ □
// □ □ □ □
```
二维数组存储的是一维数组
```golang
a2 := [2][3]int{
		{2, 2, 2},
		{3, 4, 5},
	}
for _ , arr := range a2 { //遍历该二维数组存储的一维数组
    for _ , value := range arr{ //遍历被存储的一维数组的每个元素
        fmt.Print(value)
    }
//输出:2       2       2       3       4       5
}
```
## 切片
### 概念
切片（slice）是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个**引用类型**。
> 切片本身不存储数据，而是指向一个底层数组的特定部分。直接创建切片，Go会自动创建匿名底层数组

这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的**子集**。需要注意的是，终止索引标识的项不包括在切片内。
```golang
arr := [5]int{10, 20, 30, 40, 50}

slice := arr[1:4]  // 包含索引1,2,3 → [20, 30, 40]
// 索引4（值为50）不包括在内！

fmt.Println(slice) // [20 30 40]
```
切片是**可索引的**，并且可以由 len() 函数获取长度。

给定项的切片索引可能比相关数组的相同元素的索引**小**。
```golang
arr := [5]int{10, 20, 30, 40, 50}
slice := arr[2:5]  // [30, 40, 50]

// 元素30在数组中的索引是2，在切片中的索引是0
fmt.Println("数组中索引:", 2)        // 2
fmt.Println("切片中索引:", 0)        // 0
fmt.Println("值:", slice[0])        // 30
fmt.Println("值:", arr[2])         // 30（同一个元素）
```
和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个**长度可变**的数组。

多个切片如果表示同一个数组的片段，它们可以**共享数据**；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。

优点：因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go代码中切片比数组更常用。

理解切片的三要素：
- 指针：指向底层数组的起始位置
- 长度：当前包含的元素个数，len(s)
- 容量：从**起始位置到底层数组末尾**的元素个数，cap(s)

### 声明格式
一个切片在未初始化之前默认为 nil，长度为 0
```golang
var identifier []type
s2 := []int{1,2,3,4}
var slice1 []type = arr1[start:end] //初始化格式
```
如果某个人写：var slice1 []type = arr1[:] 那么 slice1 就等于完整的 arr1 数组
另外一种表述方式是：slice1 = &arr1

### 多维切片
同数组类似
内层的切片必须单独分配（通过 make 函数）

### 用 make() 创建一个切片
当相关数组还没有定义时，我们可以使用 make() 函数来创建一个切片 同时创建好相关数组：
``var slice1 []type = make([]type, len)``
``slice1 := make([]type, len)``
make 的使用方式是：`func make([]T, len, cap)`，其中 cap 是可选参数

### new() 和 make() 的区别
- new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为\*T的**内存地址**：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于**值类型**如数组和结构体；它相当于 &T{}
- make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的**引用类型**：切片、map 和 channel

换言之，new 函数**分配内存**，make 函数**初始化**

### 切片重组
改变切片长度的过程称之为**切片重组 reslicing**
做法如下：``slice1 = slice1[0:end]``
切片重组后会改变视图窗口，**不会改变**底层数组

### 切片复制
**copy()**是一个内置函数，用于将一个切片的数据**复制**到另一个切片
``func copy(dst, src []Type) int``

- dst：目标切片（数据复制到这里）
- src：源切片（数据从这里复制）
- 返回值：实际复制的元素个数

**处理重叠情况**
```golang
func main() {
    slice := []int{1, 2, 3, 4, 5}
    
    // 目标切片和源切片有重叠
    n := copy(slice[1:], slice)  // 从开头复制到索引1开始的位置
    
    fmt.Printf("复制了%d个元素\n", n)  // 复制了4个元素
    fmt.Printf("结果: %v\n", slice)   // [1 1 2 3 4]
    
    // 解释：相当于把slice[0:4]复制到slice[1:5]
    // 原始: [1, 2, 3, 4, 5]
    // 复制后: [1, 1, 2, 3, 4]
}
```

### 切片追加
**append()**是Go语言的一个内置函数，用于向切片**追加新元素**
``func append(s []T, x ...T) []T``
- s：目标切片
- x ...T：要追加的一个或多个元素（必须是相同类型T）
- 返回值：新的切片（可能指向不同的内存地址）

例子：
```golang
slice := []int{1, 2, 3}
slice := append(slice, 4, 5, 6) //{1,2,3,4,5,6}
```

Go语言的**解包语法**（也叫展开操作符），意思是："把切片 y中的所有元素展开，作为单独的参数传递给 append函数"
```golang
x := []int{1, 2, 3}
y := []int{4, 5, 6}

//使用解包语法：简洁高效
x = append(x, y...)  // 等价于 append(x, 4, 5, 6)
fmt.Println(x) // [1 2 3 4 5 6]
```
当容量不足时，append()会创建新的底层数组

## for-range结构
```golang
for index, value := range slice1 {
    ...
}
```
第一个返回值 index 是数组或者切片的索引，第二个是在该索引位置的值；他们都是仅在 for 循环内部可见的局部变量。value 只是 slice1 某个索引位置的值的一个拷贝，不能用来修改 slice1 该索引位置的值
\_可用于忽略索引``for _, season = range seasons``
如果你只需要索引，你可以**忽略第二个变量**``for ix := range seasons``

### 多维数组for-range
切片与数组类似
```golang
for _ , arr := range a2 { //遍历该二维数组存储的一维数组
    for _ , value := range arr{ //遍历被存储的一维数组的每个元素
        fmt.Print(value)
    }
```

## 字符串、数组和切片的应用
假设 s 是一个字符串（本质上是一个字节数组），那么就可以直接通过 c := []bytes(s) 来获取一个字节的切片 c

Go 语言中的字符串是不可变的，也就是说`str[index]`这样的表达式是不可以被放在等号左侧的。如果尝试运行`str[i] = 'D'`会得到错误`cannot assign to str[i]`
因此，必须先将字符串转换成字节数组，然后再通过修改数组中的元素值来达到修改字符串的目的，最后将字节数组转换回字符串格式
例如，将字符串 "hello" 转换为 "cello"：
```golang
s := "hello"
c := []byte(s)
c[0] = 'c'
s2 := string(c) // s2 == "cello"
```
???