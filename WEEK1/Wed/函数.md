## 71函数中变量的作用域
**局部变量**：函数**内部**定义的变量

- 变量在哪里定义，就只能在哪里使用

**全局变量**：函数**外部**定义的变量

- 不支持简短定义的写法
- 所有函数都可以使用，而且**共享**这一份数据

不同作用域内变量名可以**相同**

## 72递归函数

## 73defer语句
1. defer关键字，用来延迟一个函数或者方法的执行

2. defer的用法：
	- A：对象.close()，临时文件的删除
		- 文件.open()
		- defer close()
		- 读或写
	- B：panic()和recover()

3. 如果多个defer函数：先延迟的后执行，后延迟的先执行

4. defer函数传递参数的时候：defer函数调用时，就**已经传递**了参数数据了，只是暂时不执行函数中的代码

5. defer函数注意点：
	- defer语句所在函数称作**外围函数**，当外围函数代码执行完后再执行defer语句
	- 当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行
	- 当执行外围函数中的**return语句**时，只有其中的所有的延迟函数都执行完毕后，外围函数才会真正返回
	- 当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数

## 74函数的数据类型
func(参数列表的数据类型)(返回值列表的数据类型)
```golang
func main(){
	fmt.Printf("%T\n"，fun1)
}

func fun1(a,b string,c,d int)(string,int,float64){
	return 0 0
}
```
输出
func(string, string, int, int)(string, int, float64)

## 75函数的本质
**函数名**指向函数体的**内存地址**
函数是一种**特殊的变量**
```golang
func main(){
	var c func(int,int)
	fmt.Println(c) //<nil>
	c = fun1
	fmt.Println(c) //打印该函数的内存地址
	fun1(10，20)
	c(100，200) //结果与上一行相同。c也是函数类型的，加小括号也可以被调用
}

func fun1(a,b int){
	fmt.Println(a,b)
}
```
注意fun1()和fun1不同
前者得到fun1被执行后返回的结果
后者指向函数体的内存地址

## 76匿名函数
没有名字的函数
定义一个匿名函数，直接进行调用
通常只能使用一次。也可以将匿名函数赋值给一个函数变量，可以多次使用
```golang
func main(){
	fmt.Println("我是匿名函数")
}() //后接小括号立即调用

fun1 := func(){
	fmt.Println()
} //将匿名函数赋值给fun1，可以多次调用

func (a,b int)int{
	return a + b
}(10,20) //带参数和返回值的匿名函数
```
匿名函数作用
Go语言支持函数式编程：
- 将匿名函数作为另一个函数的**参数**，回调函数
- 将匿名函数作为另一个函数的**返回值**，可以形成**闭包结构**

## 77回调函数
fun1(),fun2()
将fun1函数作为fun2这个函数的参数
- 高阶函数：fun2，接收了一个函数作为参数的函数
- 回调函数：fun1，作为另一个函数的参数的函数
```golang
func main(){
	res2 := oper(10, 20, add)
	res3 := oper(5, 2, sub)
	fmt.Println(res2,res3) //30,3
	
	res3 := oper(100, 8, func(a,b int)int{
		if b == 0{
			fmt.Println()
			return 0
		}
		return a / b
	}) //将匿名函数作为参数传入oper
	fmt.Println(res3)
}

func add(a,b int)int{
	return a + b
}

fun sub(a,b int)int{
	return a-b
}
func oper(a,b int,fun func(int,int)int)int{
	fmt.Println(a,b,fun)
	res := fun(a,b) //add和sub在这一行才被真正调用
	return res
}
```

## 78闭包
closure：
- 一个外层函数中，有内层函数，该内层函数中，会操作外层函数的局部变量（外层函数中的参数，或外层函数中直接定义的变量），并且该外层函数的返回值就是这个内层函数。
- 这个内层函数和外层函数的局部变量，统称为闭包结构
- 局部变量的生命周期会发生改变，正常的局部变量随着函数调用而创建，随着函数的结束而销毁。但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁，因为内层函数还要继续使用

```golang
func main(){
	res1 := increment() //res1 = fun
	v1 := res1()
	fmt.Println(v1) //1
	v1 := res2() //2
	res2 := increment() //产生一个新的局部变量i，而fun访问的也是对应的局部变量i
}

func increment()func()int{ //外层函数
	//1.定义了一个局部变量
	i := 0
	//2.定义了一个匿名函数，给变量自增并返回
	fun := func ()int{ //内层函数
		i++
		return i
	}
	//3.返回该匿名函数
	return fun
}
```
![png1](C:\LEMON\NOTE\golang\90c83ea6-a211-4249-a18f-ae4a41892418.png)